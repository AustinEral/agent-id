# Craft Session Notes â€” 2026-02-06 20:59 UTC

## Session Start: 20:59 UTC

## Phase 0: Existing Work

### Recent commits on main:
- b9f7f68 Add philosophy to README
- 12fe40a fmt
- 7584731 Update SECURITY.md: defer nonce cache fix
- fe18d27 Add Security & Hardening Roadmap (#12)
- 89c03b4 Polish SDK docs (#14)
- 6822739 Remove recovery key functionality (#13)

### Open PRs (to avoid):
- #21 - Fuzz testing infrastructure
- #20 - JCS canonicalization (RFC 8785)
- #19 - Zeroize for secret key material
- #18 - Interoperability test vectors
- #17 - Session key delegation verification
- #16 - Safe Debug traits for key types

### SECURITY.md items:
1. Nonce cache memory leak - DEFERRED
2. Session key delegation - PR #17
3. Mutex poisoning - NOT ADDRESSED (noted as acceptable)
4. Test vectors - PR #18
5. Fuzz testing - PR #21

## Phase 2: Research

### Projects Studied

**subtle (dalek-cryptography)**
- https://docs.rs/subtle
- Constant-time operations for crypto
- ConstantTimeEq trait for safe comparisons
- Used internally by ed25519-dalek
- Prevents timing side-channel attacks

**Key patterns observed:**
1. Use constant-time comparison for any secret-dependent data
2. Challenge hashes ARE secret-dependent (verifier knowledge)
3. Timing differences in hash comparison can leak info about expected hash

### Timing Attack Surface in AIP

Current vulnerable code in protocol.rs:

```rust
// Line 89
if proof.challenge_hash != expected_hash {
    return Err(HandshakeError::InvalidSignature);
}

// Line 234
if counter_proof.challenge_hash != expected_hash {
    return Err(HandshakeError::InvalidSignature);
}
```

These use Rust's default string comparison which:
- Short-circuits on first mismatch
- Timing reveals information about expected hash

### Attack Scenario

1. Attacker sends crafted proofs with different hash prefixes
2. Measures response time for each
3. Longer time = more matching prefix bytes
4. Eventually reconstructs expected hash
5. Can bypass verification without knowing the challenge

### Fix

Use subtle::ConstantTimeEq for hash comparisons:

```rust
use subtle::ConstantTimeEq;

// Constant-time byte comparison
if challenge_hash_bytes.ct_eq(&expected_hash_bytes).unwrap_u8() != 1 {
    return Err(HandshakeError::InvalidSignature);
}
```

## Phase 3: Analysis

### Why this matters
- AIP is security-critical infrastructure
- Handshake verification is the core security boundary
- Even small leaks compound over many observations
- Defense in depth: even if attacks are hard, prevent them

### What's already good
- ed25519-dalek uses subtle internally for signatures
- Error messages don't leak sensitive info
- Input validation is robust

### What this PR addresses
- Challenge hash comparison in verify_proof()
- Challenge hash comparison in verify_counter_proof()
- Adds subtle dependency (already used by ed25519-dalek transitively)

## Phase 4: Implementation Plan

1. Add subtle to workspace dependencies
2. Add subtle to aip-handshake dependencies
3. Convert hash comparisons to constant-time
4. Add tests verifying behavior
5. Update SECURITY.md

## Phase 5: Decision

**Selected improvement:** Constant-time challenge hash comparison

**Why this over alternatives:**
- Mutex poisoning is noted as acceptable in SECURITY.md
- Other items already have open PRs
- This is a real security improvement
- Small, focused change
- Follows dalek-cryptography patterns

## Session End: TBD

## Session End: 21:05 UTC
Total duration: ~6 minutes

## Result
PR #22: Use constant-time comparison for challenge hash verification
https://github.com/AustinEral/aip/pull/22
