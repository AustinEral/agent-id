# AIP Craft Session Notes
**Date:** 2026-02-06
**Session Start:** 18:46 UTC

## Phase 0: Existing Work (Avoid Duplicating)

### Recent Merged (main):
- b9f7f68 Add philosophy to README
- 12fe40a fmt
- 7584731 Update SECURITY.md: defer nonce cache fix
- fe18d27 Add Security & Hardening Roadmap (#12)
- 89c03b4 Polish SDK docs (#14)
- 6822739 Remove recovery key functionality (#13)

### Open PRs (DO NOT DUPLICATE):
- #19: Enable zeroize for secret key material (2026-02-06)
- #18: Add interoperability test vectors (2026-02-06)
- #17: Implement session key delegation verification in handshake (2026-02-06)
- #16: Implement safe Debug traits for key types (2026-02-06)

### Closed but not merged:
- #15: Fix nonce cache memory leak (deferred per SECURITY.md)

## Phase 2: Research Notes

### ed25519-dalek
- Uses zeroize feature for automatic secret key zeroing
- SigningKey implements Zeroize on drop when feature enabled
- AIP PR #19 addresses this

### serde_json_canonicalizer
- RFC 8785 compliant JCS implementation
- Handles edge cases: Unicode normalization, number formatting, proper escaping
- Well-maintained, production-ready

### Key observations from exemplary projects:
1. **ring** - Explicit about what's constant-time, clear documentation
2. **age** - Clean error types, no info leakage in errors
3. **rustls** - Extensive test vectors, audited

## Phase 3: Security Patterns

### What stands out:
- Constant-time comparison for secrets (ed25519-dalek handles this)
- Zeroize on drop (PR #19 addresses)
- Safe Debug (PR #16 addresses)
- Proper canonicalization for signing (NOT YET ADDRESSED)

## Phase 4: AIP Analysis

### Current state of signing.rs:
```rust
/// Canonicalize a JSON value using JCS (RFC 8785).
///
/// This produces a deterministic byte representation suitable for signing.
pub fn canonicalize<T: Serialize>(value: &T) -> Result<Vec<u8>> {
    // serde_json with sorted keys approximates JCS
    // For production, use a proper JCS library  <-- CODE ADMITS THIS
    ...
}
```

### Issues with current implementation:
1. **Unicode handling** - May not follow RFC 8785 for Unicode escaping
2. **Number formatting** - Floating point precision not guaranteed
3. **Escape sequences** - Custom implementation may miss edge cases
4. **Interoperability** - Other implementations using proper JCS may produce different output

### Why this matters:
- Signatures are verified against canonical bytes
- Different canonicalization = signature verification failure
- Cross-implementation interop is a stated goal (test vectors PR exists)

## Phase 5: Selected Improvement

**Replace custom JCS approximation with proper RFC 8785 implementation**

### Why this over other options:
1. Code itself acknowledges it's not production-ready
2. Security-critical path (signature generation/verification)
3. Interoperability concern (other agents using proper JCS)
4. Clean fix with well-maintained crate
5. Not already addressed by any open PR

### Tradeoffs:
- Adds a dependency (serde_json_canonicalizer)
- Slight API change (function signatures may change)
- Benefits outweigh: correctness, interoperability, maintainability

## Session Progress
- [x] Phase 0: Check existing work
- [x] Phase 1: Understand project
- [x] Phase 2: Research
- [x] Phase 3: Document thinking
- [x] Phase 4: Analyze AIP
- [x] Phase 5: Select improvement
- [ ] Phase 6: Implement
- [ ] Phase 7: PR



## Phase 6 & 7: Implementation Complete

PR #20 created: https://github.com/AustinEral/aip/pull/20

Session End: 18:50 UTC
Duration: ~4 minutes

